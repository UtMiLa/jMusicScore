declare module "application" {
    export module Application {
        interface IPlugIn<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            init(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            getId(): string;
        }
        interface IBuilder<Type> {
            (): Type;
        }
        interface IReaderPlugIn<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> extends IPlugIn<TDocumentType, TStatusManager> {
            supports(type: string): boolean;
            getExtension(type: string): string;
            load(data: any): void;
            getId(): string;
            getFormats(): string[];
        }
        interface IWriterPlugIn<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> extends IPlugIn<TDocumentType, TStatusManager> {
            supports(type: string): boolean;
            getExtension(type: string): string;
            save(): string;
            getId(): string;
            getFormats(): string[];
        }
        interface ICommand<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            execute(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            undo?(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            [param: string]: any;
        }
        interface IValidator<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            validate(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
        }
        interface IDesigner<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            validate(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
        }
        interface IEventProcessor<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            init(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            exit(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            midinoteoff?(app: AbstractApplication<TDocumentType, TStatusManager>, event: IMessage): boolean;
            keypressed?(app: AbstractApplication<TDocumentType, TStatusManager>, event: IMessage): boolean;
            keyup?(app: AbstractApplication<TDocumentType, TStatusManager>, event: IMessage): boolean;
            keydown?(app: AbstractApplication<TDocumentType, TStatusManager>, event: IMessage): boolean;
        }
        interface IFileManager<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            init(app: AbstractApplication<TDocumentType, TStatusManager>): void;
            exit(app: AbstractApplication<TDocumentType, TStatusManager>): void;
            getFileList(handler: (data: string[]) => void): void;
            loadFile(name: string, handler: (data: string, name: string) => void): void;
            saveFile(name: string, data: string, handler: (res: string) => void): void;
            getId(): string;
        }
        interface IDesktopArea {
        }
        interface IDesktopManager {
            addArea(area: IDesktopArea, placement: string): void;
            removeArea(area: IDesktopArea): void;
        }
        interface IFeedbackClient {
            changed(status: IStatusManager, key: string, val: any): void;
        }
        interface IFeedbackManager {
            changed(status: IStatusManager, key: string, val: any): void;
            registerClient(client: IFeedbackClient): void;
            removeClient(client: IFeedbackClient): void;
        }
        interface IStatusManager {
            setFeedbackManager(f: IFeedbackManager): void;
        }
        interface IMessage {
            key?: string;
            [others: string]: any;
        }
        interface IEventReceiver {
            processEvent(name: string, message: IMessage): boolean;
        }
        interface IAppDoc {
            clear(): void;
        }
        class AbstractApplication<TDocumentType extends IAppDoc, TStatusManager extends IStatusManager> {
            constructor(score: TDocumentType, status: TStatusManager);
            document: TDocumentType;
            private plugins;
            private readers;
            private writers;
            private fileManagers;
            private validators;
            private designers;
            private editors;
            private feedbackManager;
            private status;
            readonly Status: TStatusManager;
            readonly FeedbackManager: IFeedbackManager;
            addPlugin(plugin: IPlugIn<TDocumentType, TStatusManager>): void;
            addReader(reader: IReaderPlugIn<TDocumentType, TStatusManager>): void;
            addWriter(writer: IWriterPlugIn<TDocumentType, TStatusManager>): void;
            addFileManager(fileManager: IFileManager<TDocumentType, TStatusManager>): void;
            addValidator(validator: IValidator<TDocumentType, TStatusManager>): void;
            addDesigner(designer: IDesigner<TDocumentType, TStatusManager>): void;
            getFileOpenTypes(): string[];
            getFileSaveTypes(): string[];
            getFileManagerIds(): string[];
            getFileList(fileManager: string, handler: (data: string[]) => void): void;
            setExtension(name: string, type: string): string;
            saveUsing(name: string, fileManager: string, type: string): void;
            save(name: string, fileManager: IFileManager<TDocumentType, TStatusManager>, type: string): void;
            saveToString(type: string): string;
            loadUsing(name: string, fileManager: string, type: string): void;
            load(name: string, fileManager: IFileManager<TDocumentType, TStatusManager>, type: string): void;
            loadFromString(data: any, type: string): void;
            getPlugin(id: string): IPlugIn<TDocumentType, TStatusManager>;
            private undoStack;
            private redoStack;
            executeCommand(command: ICommand<TDocumentType, TStatusManager>): void;
            canUndo(): boolean;
            canRedo(): boolean;
            undo(): void;
            redo(): void;
            private fixModel();
            private fixDesign();
            private fixEditors();
            private eventProcessors;
            registerEventProcessor(eventProc: IEventProcessor<TDocumentType, TStatusManager>): void;
            unregisterEventProcessor(eventProc: IEventProcessor<TDocumentType, TStatusManager>): void;
            processEvent(name: string, message: IMessage): boolean;
        }
    }
}
declare module "Configuration" {
    import { Application } from "application";
    export module Configuration {
        enum ConfigurationType {
            ctFileManager = 0,
            ctPlugin = 1,
            ctValidator = 2,
        }
        interface IConfiguration<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> {
            type: ConfigurationType;
            installer(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            label: string;
            active: boolean;
        }
        interface IPluginClass<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> {
            new (): Application.IPlugIn<TDocumentType, TStatusManager>;
        }
        class PluginConfiguration<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> implements IConfiguration<TDocumentType, TStatusManager> {
            label: string;
            type: ConfigurationType;
            active: boolean;
            private plugin;
            constructor(label: string, x: Application.IBuilder<Application.IPlugIn<TDocumentType, TStatusManager>>);
            constructor(label: string, x: IPluginClass<TDocumentType, TStatusManager>);
            installer(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
        }
        interface IValidatorClass<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> {
            new (): Application.IValidator<TDocumentType, TStatusManager>;
        }
        class ValidatorConfiguration<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> implements IConfiguration<TDocumentType, TStatusManager> {
            label: string;
            type: ConfigurationType;
            active: boolean;
            private validator;
            constructor(label: string, x: Application.IBuilder<Application.IValidator<TDocumentType, TStatusManager>>);
            constructor(label: string, x: IValidatorClass<TDocumentType, TStatusManager>);
            installer(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
        }
        interface IFileManagerClass<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> {
            new (): Application.IFileManager<TDocumentType, TStatusManager>;
        }
        class FileManagerConfiguration<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> implements IConfiguration<TDocumentType, TStatusManager> {
            label: string;
            type: ConfigurationType;
            active: boolean;
            private fileManager;
            constructor(label: string, x: Application.IBuilder<Application.IFileManager<TDocumentType, TStatusManager>>);
            constructor(label: string, x: IFileManagerClass<TDocumentType, TStatusManager>);
            installer(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
        }
        class MakeBuilder {
            static make<T>(type: any): Application.IBuilder<T>;
        }
        class ConfigurationManager<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> {
            app: Application.AbstractApplication<TDocumentType, TStatusManager>;
            constructor(app: Application.AbstractApplication<TDocumentType, TStatusManager>);
            protected configurations: IConfiguration<TDocumentType, TStatusManager>[];
            addConfiguration(configuration: IConfiguration<TDocumentType, TStatusManager>): void;
            disableConfiguration(id: string): void;
            enableConfiguration(id: string): void;
            apply(): void;
        }
    }
}
declare module "jApps.BrowserFileSystem" {
    import { Application } from "application";
    export module IO {
        class ServerFileManager<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> implements Application.IFileManager<TDocumentType, TStatusManager> {
            private ajaxUrl;
            private id;
            constructor(ajaxUrl: string, id: string);
            init(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            exit(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            getId(): string;
            getFileList(handler: (data: string[]) => void): void;
            loadFile(name: string, handler: (data: string, name: string) => void): void;
            saveFile(name: string, data: string, handler: (res: string) => void): void;
        }
        class LocalStorageFileManager<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> implements Application.IFileManager<TDocumentType, TStatusManager> {
            private id;
            constructor(id: string);
            init(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            exit(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            getId(): string;
            getFileList(handler: (data: string[]) => void): void;
            loadFile(name: string, handler: (data: string, name: string) => void): void;
            saveFile(name: string, data: string, handler: (res: string) => void): void;
        }
    }
}
declare module "Japps.ui" {
    export module UI {
        enum ActionType {
            execute = 0,
            check = 1,
            radio = 2,
        }
        interface Action {
            caption: string;
            helpText?: string;
            icon?: string;
            action: () => void;
            enabled?: () => boolean;
            visible?: () => boolean;
            type: ActionType;
        }
        interface RadioGroup {
        }
        interface ActionCollection {
            [name: string]: Action;
        }
        interface ToolbarDef {
        }
        interface ToolGroupDef {
        }
        interface ActionMenuItemDef {
            action: string;
        }
        interface ParentMenuItemDef {
            action?: string;
            subItems: MenuItemDef[];
            caption: string;
        }
        type MenuItemDef = ActionMenuItemDef | ParentMenuItemDef;
        interface MenuDef {
            items: MenuItemDef[];
        }
        interface Toolbar {
        }
        interface ActionManager {
        }
        class MenuManager implements ActionManager {
            constructor();
            _actions: ActionCollection;
            addActions(actions: ActionCollection): void;
            setMenu(menuDef: MenuDef): void;
            updateMenuItems(): void;
        }
        class ToolbarManager implements ActionManager {
            _actions: ActionCollection;
            addActions(actions: ActionCollection): void;
        }
        class CommandLineManager implements ActionManager {
        }
        class JQUIMenuManager extends MenuManager {
            private element;
            constructor(element: string);
            private createMenuButton(item);
            setMenu(menuDef: MenuDef): void;
            updateMenuItems(): void;
        }
        class JQUIToolbarManager extends ToolbarManager {
        }
        class JQCommandLineManager extends CommandLineManager {
        }
    }
}
declare module "keyboard" {
    import { Application } from "application";
    export module Editors {
        class KeybordInputPlugin<TDocumentType extends Application.IAppDoc, TStatusManager extends Application.IStatusManager> implements Application.IPlugIn<TDocumentType, TStatusManager> {
            init(app: Application.AbstractApplication<TDocumentType, TStatusManager>): void;
            getId(): string;
        }
    }
}
